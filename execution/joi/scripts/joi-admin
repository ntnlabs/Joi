#!/bin/bash
# Joi Admin Tool - Memory and key management
#
# Usage: sudo joi-admin purge [FLAGS]
#
# SAFE BY DEFAULT: No flags = no action. Must explicitly specify what to purge.

set -Eeuo pipefail

SCRIPT_NAME=$(basename "$0")
SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd)
JOI_PY_ROOT=$(cd "$SCRIPT_DIR/.." && pwd)
MEMORY_DB="${JOI_MEMORY_DB:-/var/lib/joi/memory.db}"
NONCE_DB="${JOI_NONCE_DB:-/var/lib/joi/nonces.db}"
HMAC_KEY_FILE="${JOI_HMAC_KEY_FILE:-/etc/joi/hmac.key}"
MEMORY_KEY_FILE="${JOI_MEMORY_KEY_FILE:-/etc/joi/memory.key}"
SQLCIPHER_BIN="${JOI_SQLCIPHER_BIN:-sqlcipher}"
NEBULA_DIR="/etc/nebula"
SERVICE_USER="${JOI_SERVICE_USER:-joi}"
DB_MODE=""
DB_KEY=""
DB_MODE_INITIALIZED=false

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color
DEBUG="${JOI_ADMIN_DEBUG:-0}"

if [[ "$DEBUG" == "1" ]]; then
    set -x
fi

on_err() {
    local exit_code=$?
    echo -e "${RED}Error at line ${BASH_LINENO[0]}: ${BASH_COMMAND} (exit ${exit_code})${NC}" >&2
    exit "$exit_code"
}

trap on_err ERR

usage() {
    cat << 'EOF'
Joi Admin Tool

USAGE:
    joi-admin <COMMAND> [OPTIONS]

COMMANDS:
    purge       Purge memory data and/or regenerate keys
    rag         Inspect and manage RAG knowledge sources/scopes
    summaries   Read-only context summary inspection

PURGE USAGE:
    joi-admin purge [FLAGS]

    SAFE BY DEFAULT: Running without flags does nothing.

DATA FLAGS (what to delete):
    --contexts          Delete messages and context summaries
    --facts             Delete learned user facts
    --knowledge         Delete RAG knowledge chunks
    --all-data          All of the above (contexts + facts + knowledge)

RESET FLAGS:
    --reset-counters    Reset AUTOINCREMENT counters (sqlite_sequence) for
                        messages, user_facts, context_summaries, knowledge_chunks
                        Requires global full-memory purge (no --conversation)
    --vacuum            Compact memory DB file after purge (VACUUM)
                        Requires global full-memory purge (no --conversation)
                        Shows extra warnings and asks for double confirmation

SCOPE FLAGS (limit deletion):
    --conversation ID   Only affect specific conversation (phone/group ID)
                        Without this, affects ALL conversations

KEY FLAGS:
    --hmac-key          Regenerate HMAC signing key
    --nebula-keys       Remove Nebula host keys (requires re-enrollment)
    --all-keys          Both HMAC and Nebula keys

NUCLEAR OPTIONS:
    --everything        Equivalent to --all-data --all-keys
    --nebula-ca         Also remove Nebula CA cert (true factory reset)

EXAMPLES:
    joi-admin purge                                    # Does nothing (safe)
    joi-admin purge --contexts                         # Clear all conversation history
    joi-admin purge --contexts --conversation +1234    # Clear one conversation (//reload)
    joi-admin purge --contexts --facts --conversation +1234  # //restart equivalent
    joi-admin purge --all-data --conversation +1234    # //reset equivalent
    joi-admin purge --all-data --reset-counters        # Full data purge + ID counters reset
    joi-admin purge --all-data --reset-counters --vacuum
    joi-admin purge --all-data --all-keys              # Customer handoff
    joi-admin purge --everything --nebula-ca           # True factory reset

RAG USAGE:
    joi-admin rag <SUBCOMMAND> [OPTIONS]

RAG SUBCOMMANDS:
    list                List RAG knowledge sources
    scopes              List unique RAG scopes with totals
    stats               Show RAG totals
    delete              Delete a RAG source (optionally within one scope)
    rescope             Move RAG chunks from one scope to another

RAG EXAMPLES:
    joi-admin rag list
    joi-admin rag scopes
    joi-admin rag stats
    joi-admin rag delete --source '+123456789/diary.txt' --scope -123456789
    joi-admin rag rescope --from +123456789 --to -123456789

SUMMARIES USAGE:
    joi-admin summaries list [--conversation ID] [--limit N]
    joi-admin summaries show --id ID
    joi-admin summaries delete --id ID

SUMMARIES EXAMPLES:
    joi-admin summaries list
    joi-admin summaries list --conversation +123456789
    joi-admin summaries list --conversation group_id_here --limit 20
    joi-admin summaries show --id 42
    joi-admin summaries delete --id 42

EOF
    exit 0
}

error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

warn() {
    echo -e "${YELLOW}Warning: $1${NC}" >&2
}

info() {
    echo -e "${GREEN}$1${NC}"
}

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        error "This script must be run as root (sudo)"
    fi
}

sql_escape_literal() {
    # Escape single quotes for SQL string literals.
    printf "%s" "$1" | sed "s/'/''/g"
}

ensure_db_mode() {
    if $DB_MODE_INITIALIZED; then
        return
    fi
    DB_MODE_INITIALIZED=true

    if [[ ! -f "$MEMORY_DB" ]]; then
        return
    fi

    if command -v sqlite3 >/dev/null 2>&1; then
        # Probe schema access (not just SELECT 1), so encrypted DBs are rejected.
        if sqlite3 "$MEMORY_DB" "SELECT count(*) FROM sqlite_master WHERE type='table';" >/dev/null 2>&1; then
            DB_MODE="sqlite3"
            return
        fi
    fi

    if command -v "$SQLCIPHER_BIN" >/dev/null 2>&1; then
        if [[ -f "$MEMORY_KEY_FILE" ]]; then
            DB_KEY=$(tr -d '\r\n' < "$MEMORY_KEY_FILE")
            if [[ -n "$DB_KEY" ]]; then
                if "$SQLCIPHER_BIN" "$MEMORY_DB" <<EOF >/dev/null 2>&1
PRAGMA key = '$DB_KEY';
SELECT count(*) FROM sqlite_master WHERE type='table';
EOF
                then
                    DB_MODE="sqlcipher_key"
                    return
                fi
            fi
        fi

        # Fallback: sqlcipher can also open plaintext DBs.
        if "$SQLCIPHER_BIN" "$MEMORY_DB" "SELECT count(*) FROM sqlite_master WHERE type='table';" >/dev/null 2>&1; then
            DB_MODE="sqlcipher_plain"
            return
        fi
    fi

    error "Cannot open memory DB ($MEMORY_DB). Install sqlite3/sqlcipher and check JOI_MEMORY_KEY_FILE."
}

db_exec() {
    local sql="$1"
    ensure_db_mode

    if [[ "$DEBUG" == "1" ]]; then
        echo "[DEBUG] DB mode: ${DB_MODE}" >&2
        echo "[DEBUG] SQL: ${sql}" >&2
    fi

    case "$DB_MODE" in
        sqlite3)
            sqlite3 "$MEMORY_DB" "$sql"
            ;;
        sqlcipher_key)
            "$SQLCIPHER_BIN" "$MEMORY_DB" <<EOF
PRAGMA key = '$DB_KEY';
$sql
EOF
            ;;
        sqlcipher_plain)
            "$SQLCIPHER_BIN" "$MEMORY_DB" "$sql"
            ;;
        *)
            error "Database engine not initialized"
            ;;
    esac
}

db_scalar() {
    local sql="$1"
    local output
    output=$(db_exec "$sql")

    # sqlcipher can emit a standalone "ok" line from PRAGMA key.
    # Return first real scalar value.
    printf "%s\n" "$output" | awk 'NF && $0 != "ok" { print; exit }'
}

restore_knowledge_fts_with_python() {
    # Fallback recovery path for sqlcipher CLI builds without FTS5:
    # use Joi's Python MemoryStore (which typically has working FTS5 support)
    # to recreate missing triggers and rebuild the FTS index.
    if ! command -v python3 >/dev/null 2>&1; then
        warn "python3 not available; cannot restore knowledge FTS triggers automatically."
        return 1
    fi

    local py_err=""
    if ! py_err=$(PYTHONPATH="$JOI_PY_ROOT${PYTHONPATH:+:$PYTHONPATH}" \
        JOI_MEMORY_DB="$MEMORY_DB" \
        JOI_MEMORY_KEY_FILE="$MEMORY_KEY_FILE" \
        python3 <<'PY' 2>&1 >/dev/null
import os
import sys

try:
    from memory import MemoryStore
except Exception as e:
    print(f"import_failed: {e}")
    sys.exit(1)

try:
    store = MemoryStore(os.environ["JOI_MEMORY_DB"])
    # _init_schema() runs in constructor and recreates missing triggers.
    # Rebuild FTS index to resync after trigger-less deletes.
    conn = store._connect()  # internal helper is acceptable in admin recovery path
    try:
        conn.execute("INSERT INTO knowledge_fts(knowledge_fts) VALUES('rebuild')")
        conn.commit()
    except Exception:
        # If rebuild fails, triggers may still be restored; keep best-effort behavior.
        pass
except Exception as e:
    print(f"restore_failed: {e}")
    sys.exit(1)
PY
    ); then
        warn "Could not auto-restore knowledge FTS triggers/index via Python fallback."
        warn "Restart joi-api after installing an FTS5-capable sqlcipher to restore RAG indexing."
        if [[ -n "${py_err//[$'\t\r\n ']/}" ]]; then
            warn "Python restore error: $py_err"
        fi
        return 1
    fi

    info "  Restored knowledge FTS triggers/index via Python MemoryStore"
    return 0
}

# Purge messages and summaries
purge_contexts() {
    local conversation="$1"
    local count=0

    if [[ ! -f "$MEMORY_DB" ]]; then
        warn "Memory database not found: $MEMORY_DB"
        return
    fi

    if [[ -n "$conversation" ]]; then
        local conversation_escaped
        conversation_escaped=$(sql_escape_literal "$conversation")
        echo "Purging contexts for conversation: $conversation"
        count=$(db_scalar "SELECT COUNT(*) FROM messages WHERE conversation_id = '$conversation_escaped';")
        # Break self-referential reply chains before deleting parent rows.
        # Without this, SQLite can fail with FOREIGN KEY constraint errors.
        db_exec "UPDATE messages SET reply_to_id = NULL WHERE reply_to_id IN (SELECT message_id FROM messages WHERE conversation_id = '$conversation_escaped');"
        db_exec "DELETE FROM messages WHERE conversation_id = '$conversation_escaped';"
        db_exec "DELETE FROM context_summaries WHERE conversation_id = '$conversation_escaped';"
    else
        echo "Purging ALL contexts"
        count=$(db_scalar "SELECT COUNT(*) FROM messages;")
        # Clear reply links first to avoid FK failures on bulk delete.
        db_exec "UPDATE messages SET reply_to_id = NULL WHERE reply_to_id IS NOT NULL;"
        db_exec "DELETE FROM messages;"
        db_exec "DELETE FROM context_summaries;"
    fi

    info "  Deleted $count messages"
}

# Purge user facts
purge_facts() {
    local conversation="$1"
    local count=0

    if [[ ! -f "$MEMORY_DB" ]]; then
        warn "Memory database not found: $MEMORY_DB"
        return
    fi

    if [[ -n "$conversation" ]]; then
        local conversation_escaped
        conversation_escaped=$(sql_escape_literal "$conversation")
        echo "Purging facts for conversation: $conversation"
        count=$(db_scalar "SELECT COUNT(*) FROM user_facts WHERE conversation_id = '$conversation_escaped';")
        db_exec "DELETE FROM user_facts WHERE conversation_id = '$conversation_escaped';"
    else
        echo "Purging ALL facts"
        count=$(db_scalar "SELECT COUNT(*) FROM user_facts;")
        db_exec "DELETE FROM user_facts;"
    fi

    info "  Deleted $count facts"
}

# Purge knowledge chunks
purge_knowledge() {
    local count=0
    local delete_err=""
    local dropped_fts_triggers=false

    if [[ ! -f "$MEMORY_DB" ]]; then
        warn "Memory database not found: $MEMORY_DB"
        return
    fi

    echo "Purging knowledge chunks"
    count=$(db_scalar "SELECT COUNT(*) FROM knowledge_chunks;")

    # Primary path: delete chunks directly.
    # Fallback path: some sqlcipher builds lack FTS5 module and fail via triggers.
    if ! delete_err=$(db_exec "DELETE FROM knowledge_chunks;" 2>&1); then
        if printf "%s" "$delete_err" | grep -qi "no such module: fts5"; then
            warn "FTS5 module unavailable in current sqlcipher; dropping knowledge FTS triggers and retrying."
            db_exec "DROP TRIGGER IF EXISTS knowledge_ai;"
            db_exec "DROP TRIGGER IF EXISTS knowledge_ad;"
            db_exec "DROP TRIGGER IF EXISTS knowledge_au;"
            dropped_fts_triggers=true
            db_exec "DELETE FROM knowledge_chunks;"
        else
            printf "%s\n" "$delete_err" >&2
            error "Failed to purge knowledge chunks"
        fi
    fi

    # Also clear FTS index if available in this engine build.
    if ! db_exec "DELETE FROM knowledge_fts;" >/dev/null 2>&1; then
        warn "Skipping knowledge_fts clear (FTS5 module not available in this sqlcipher build)."
    fi

    if $dropped_fts_triggers; then
        restore_knowledge_fts_with_python || true
    fi

    info "  Deleted $count knowledge chunks"
}

# Purge nonce database
purge_nonces() {
    if [[ -f "$NONCE_DB" ]]; then
        echo "Purging nonce database"
        rm -f "$NONCE_DB"
        info "  Deleted $NONCE_DB"
    fi
}

# Regenerate HMAC key
regenerate_hmac() {
    echo "Regenerating HMAC key"

    local key_dir
    key_dir=$(dirname "$HMAC_KEY_FILE")

    if [[ ! -d "$key_dir" ]]; then
        mkdir -p "$key_dir"
        chown "$SERVICE_USER:$SERVICE_USER" "$key_dir"
        chmod 700 "$key_dir"
    fi

    # Generate new key
    local new_key
    new_key=$(openssl rand -hex 32)

    umask 077
    echo "$new_key" > "$HMAC_KEY_FILE"
    chmod 600 "$HMAC_KEY_FILE"
    chown "$SERVICE_USER:$SERVICE_USER" "$HMAC_KEY_FILE"

    # Also purge nonces since old signatures are invalid
    purge_nonces

    info "  New HMAC key written to $HMAC_KEY_FILE"
    warn "  Mesh VM must also update its HMAC key to match!"
}

# Remove Nebula host keys
purge_nebula_keys() {
    echo "Removing Nebula host keys"

    local removed=0
    for f in "$NEBULA_DIR"/host.key "$NEBULA_DIR"/host.crt; do
        if [[ -f "$f" ]]; then
            rm -f "$f"
            info "  Deleted $f"
            ((removed++))
        fi
    done

    if [[ $removed -eq 0 ]]; then
        warn "  No Nebula host keys found"
    else
        warn "  Host must be re-enrolled with Nebula CA"
    fi
}

# Remove Nebula CA (factory reset)
purge_nebula_ca() {
    echo "Removing Nebula CA certificate"

    if [[ -f "$NEBULA_DIR/ca.crt" ]]; then
        rm -f "$NEBULA_DIR/ca.crt"
        info "  Deleted $NEBULA_DIR/ca.crt"
        warn "  Complete Nebula re-setup required!"
    else
        warn "  No Nebula CA found"
    fi
}

# Reset system state
reset_system_state() {
    if [[ ! -f "$MEMORY_DB" ]]; then
        return
    fi

    echo "Resetting system state"
    db_exec "$(cat << 'SQL'
UPDATE system_state SET value = '0' WHERE key IN (
    'last_interaction_at',
    'last_impulse_check_at',
    'messages_sent_this_hour',
    'messages_sent_hour_start',
    'last_context_cleanup_at',
    'last_memory_consolidation_at'
);
UPDATE system_state SET value = '' WHERE key = 'current_conversation_topic';
UPDATE system_state SET value = '"idle"' WHERE key = 'agent_state';
SQL
)"
    info "  System state reset"
}

reset_autoincrement_counters() {
    if [[ ! -f "$MEMORY_DB" ]]; then
        return
    fi

    echo "Resetting AUTOINCREMENT counters"

    local non_empty_tables
    non_empty_tables=$(db_exec "$(cat << 'SQL'
SELECT table_name || ' (' || row_count || ' rows)'
FROM (
    SELECT 'messages' AS table_name, COUNT(*) AS row_count FROM messages
    UNION ALL
    SELECT 'user_facts', COUNT(*) FROM user_facts
    UNION ALL
    SELECT 'context_summaries', COUNT(*) FROM context_summaries
    UNION ALL
    SELECT 'knowledge_chunks', COUNT(*) FROM knowledge_chunks
) t
WHERE row_count > 0
ORDER BY table_name;
SQL
)" | awk 'NF && $0 != "ok"')

    if [[ -n "${non_empty_tables//[$'\t\r\n ']/}" ]]; then
        error "--reset-counters requires empty memory tables, found data in: $non_empty_tables"
    fi

    db_exec "DELETE FROM sqlite_sequence WHERE name IN ('messages','user_facts','context_summaries','knowledge_chunks');"
    info "  AUTOINCREMENT counters reset"
}

vacuum_memory_db() {
    if [[ ! -f "$MEMORY_DB" ]]; then
        warn "Memory database not found: $MEMORY_DB"
        return
    fi

    echo "Running VACUUM on memory database"
    db_exec "VACUUM;"
    info "  Memory database compacted"
}

rag_delete_chunks() {
    local source="$1"
    local scope="${2:-}"
    local delete_err=""
    local dropped_fts_triggers=false

    if [[ -n "$scope" ]]; then
        local source_escaped scope_escaped
        source_escaped=$(sql_escape_literal "$source")
        scope_escaped=$(sql_escape_literal "$scope")
        if ! delete_err=$(db_exec "DELETE FROM knowledge_chunks WHERE source = '$source_escaped' AND scope = '$scope_escaped';" 2>&1); then
            if printf "%s" "$delete_err" | grep -qi "no such module: fts5"; then
                warn "FTS5 module unavailable in current sqlcipher; dropping knowledge FTS triggers and retrying."
                db_exec "DROP TRIGGER IF EXISTS knowledge_ai;"
                db_exec "DROP TRIGGER IF EXISTS knowledge_ad;"
                db_exec "DROP TRIGGER IF EXISTS knowledge_au;"
                dropped_fts_triggers=true
                db_exec "DELETE FROM knowledge_chunks WHERE source = '$source_escaped' AND scope = '$scope_escaped';"
            else
                printf "%s\n" "$delete_err" >&2
                error "Failed to delete RAG source"
            fi
        fi
    else
        local source_escaped
        source_escaped=$(sql_escape_literal "$source")
        if ! delete_err=$(db_exec "DELETE FROM knowledge_chunks WHERE source = '$source_escaped';" 2>&1); then
            if printf "%s" "$delete_err" | grep -qi "no such module: fts5"; then
                warn "FTS5 module unavailable in current sqlcipher; dropping knowledge FTS triggers and retrying."
                db_exec "DROP TRIGGER IF EXISTS knowledge_ai;"
                db_exec "DROP TRIGGER IF EXISTS knowledge_ad;"
                db_exec "DROP TRIGGER IF EXISTS knowledge_au;"
                dropped_fts_triggers=true
                db_exec "DELETE FROM knowledge_chunks WHERE source = '$source_escaped';"
            else
                printf "%s\n" "$delete_err" >&2
                error "Failed to delete RAG source"
            fi
        fi
    fi

    if $dropped_fts_triggers; then
        restore_knowledge_fts_with_python || true
    fi
}

cmd_rag() {
    if [[ ! -f "$MEMORY_DB" ]]; then
        error "Memory database not found: $MEMORY_DB"
    fi

    local subcommand="${1:-}"
    [[ -z "$subcommand" ]] && usage
    shift || true

    case "$subcommand" in
        list)
            local scope_filter=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --scope)
                        [[ -z "${2:-}" ]] && error "--scope requires a value"
                        scope_filter="$2"
                        shift 2
                        ;;
                    --help|-h)
                        echo "Usage: joi-admin rag list [--scope SCOPE]"
                        exit 0
                        ;;
                    *)
                        error "Unknown option for 'rag list': $1"
                        ;;
                esac
            done

            local where_clause=""
            if [[ -n "$scope_filter" ]]; then
                local scope_escaped
                scope_escaped=$(sql_escape_literal "$scope_filter")
                where_clause="WHERE scope = '$scope_escaped'"
            fi

            local rows
            rows=$(db_exec "$(cat <<SQL
SELECT COALESCE(scope, ''), source, COUNT(*), COALESCE(MAX(created_at), 0)
FROM knowledge_chunks
$where_clause
GROUP BY scope, source
ORDER BY scope, source;
SQL
)" | awk 'NF && $0 != "ok"')

            if [[ -z "${rows//[$'\t\r\n ']/}" ]]; then
                echo "No knowledge sources found."
                exit 0
            fi

            printf "%-40s  %-60s  %8s  %s\n" "scope" "source" "chunks" "last_updated"
            printf "%-40s  %-60s  %8s  %s\n" "-----" "------" "------" "-----------"
            while IFS='|' read -r scope source chunks last_updated; do
                [[ -z "${scope}${source}${chunks}${last_updated}" ]] && continue
                [[ -z "$scope" ]] && scope="(no scope)"
                printf "%-40s  %-60s  %8s  %s\n" "$scope" "$source" "$chunks" "$last_updated"
            done <<< "$rows"
            ;;

        scopes)
            [[ $# -gt 0 ]] && [[ "$1" != "--help" ]] && [[ "$1" != "-h" ]] && error "Usage: joi-admin rag scopes"
            local rows
            rows=$(db_exec "$(cat <<'SQL'
SELECT COALESCE(scope, ''), COUNT(DISTINCT source), COUNT(*), COALESCE(MAX(created_at), 0)
FROM knowledge_chunks
GROUP BY scope
ORDER BY scope;
SQL
)" | awk 'NF && $0 != "ok"')

            if [[ -z "${rows//[$'\t\r\n ']/}" ]]; then
                echo "No knowledge scopes found."
                exit 0
            fi

            printf "%-40s  %8s  %8s  %s\n" "scope" "sources" "chunks" "last_updated"
            printf "%-40s  %8s  %8s  %s\n" "-----" "-------" "------" "-----------"
            while IFS='|' read -r scope source_count chunk_count last_updated; do
                [[ -z "${scope}${source_count}${chunk_count}${last_updated}" ]] && continue
                [[ -z "$scope" ]] && scope="(no scope)"
                printf "%-40s  %8s  %8s  %s\n" "$scope" "$source_count" "$chunk_count" "$last_updated"
            done <<< "$rows"
            ;;

        stats)
            [[ $# -gt 0 ]] && [[ "$1" != "--help" ]] && [[ "$1" != "-h" ]] && error "Usage: joi-admin rag stats"
            local stats
            stats=$(db_exec "$(cat <<'SQL'
SELECT
  COUNT(DISTINCT COALESCE(scope, '')) AS scope_count,
  COUNT(DISTINCT COALESCE(scope, '') || CHAR(31) || source) AS source_count,
  COUNT(*) AS chunk_count
FROM knowledge_chunks;
SQL
)" | awk 'NF && $0 != "ok" { print; exit }')

            local scope_count source_count chunk_count
            IFS='|' read -r scope_count source_count chunk_count <<< "$stats"
            echo "RAG statistics"
            echo "  Scopes:  ${scope_count:-0}"
            echo "  Sources: ${source_count:-0}"
            echo "  Chunks:  ${chunk_count:-0}"
            ;;

        delete)
            local source=""
            local scope=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --source)
                        [[ -z "${2:-}" ]] && error "--source requires a value"
                        source="$2"
                        shift 2
                        ;;
                    --scope)
                        [[ -z "${2:-}" ]] && error "--scope requires a value"
                        scope="$2"
                        shift 2
                        ;;
                    --help|-h)
                        echo "Usage: joi-admin rag delete --source SOURCE [--scope SCOPE]"
                        exit 0
                        ;;
                    *)
                        error "Unknown option for 'rag delete': $1"
                        ;;
                esac
            done
            [[ -z "$source" ]] && error "rag delete requires --source"

            local source_escaped count
            source_escaped=$(sql_escape_literal "$source")
            if [[ -n "$scope" ]]; then
                local scope_escaped
                scope_escaped=$(sql_escape_literal "$scope")
                count=$(db_scalar "SELECT COUNT(*) FROM knowledge_chunks WHERE source = '$source_escaped' AND scope = '$scope_escaped';")
            else
                count=$(db_scalar "SELECT COUNT(*) FROM knowledge_chunks WHERE source = '$source_escaped';")
            fi

            if [[ "${count:-0}" == "0" ]]; then
                echo "No RAG chunks found for source '$source'${scope:+ (scope: $scope)}."
                exit 0
            fi

            echo ""
            echo "=== RAG DELETE SUMMARY ==="
            echo "  Source: $source"
            [[ -n "$scope" ]] && echo "  Scope:  $scope" || echo "  Scope:  ALL matching scopes"
            echo "  Chunks: $count"
            echo ""

            read -p "Delete these RAG chunks? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Aborted."
                exit 1
            fi

            rag_delete_chunks "$source" "$scope"
            info "Deleted $count RAG chunks"
            ;;

        rescope)
            local from_scope=""
            local to_scope=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --from)
                        [[ -z "${2:-}" ]] && error "--from requires a value"
                        from_scope="$2"
                        shift 2
                        ;;
                    --to)
                        [[ -z "${2:-}" ]] && error "--to requires a value"
                        to_scope="$2"
                        shift 2
                        ;;
                    --help|-h)
                        echo "Usage: joi-admin rag rescope --from OLD_SCOPE --to NEW_SCOPE"
                        exit 0
                        ;;
                    *)
                        error "Unknown option for 'rag rescope': $1"
                        ;;
                esac
            done
            [[ -z "$from_scope" || -z "$to_scope" ]] && error "rag rescope requires --from and --to"

            local from_escaped chunk_count source_count
            from_escaped=$(sql_escape_literal "$from_scope")
            chunk_count=$(db_scalar "SELECT COUNT(*) FROM knowledge_chunks WHERE scope = '$from_escaped';")
            source_count=$(db_scalar "SELECT COUNT(DISTINCT source) FROM knowledge_chunks WHERE scope = '$from_escaped';")

            if [[ "${chunk_count:-0}" == "0" ]]; then
                echo "No RAG chunks found in scope '$from_scope'."
                exit 0
            fi

            echo ""
            echo "=== RAG RESCOPE SUMMARY ==="
            echo "  From scope: $from_scope"
            echo "  To scope:   $to_scope"
            echo "  Sources:    $source_count"
            echo "  Chunks:     $chunk_count"
            echo ""

            read -p "Rescope these RAG chunks? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Aborted."
                exit 1
            fi

            local from_sql to_sql
            from_sql=$(sql_escape_literal "$from_scope")
            to_sql=$(sql_escape_literal "$to_scope")
            db_exec "UPDATE knowledge_chunks SET scope = '$to_sql' WHERE scope = '$from_sql';"
            info "Rescoped $chunk_count chunks: '$from_scope' -> '$to_scope'"
            ;;

        --help|-h)
            usage
            ;;

        *)
            error "Unknown rag subcommand: $subcommand"
            ;;
    esac
}

cmd_summaries() {
    if [[ ! -f "$MEMORY_DB" ]]; then
        error "Memory database not found: $MEMORY_DB"
    fi

    local subcommand="${1:-}"
    [[ -z "$subcommand" ]] && error "Usage: joi-admin summaries list [--conversation ID] [--limit N]"
    shift || true

    case "$subcommand" in
        list)
            local conversation=""
            local limit="50"

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --conversation)
                        [[ -z "${2:-}" ]] && error "--conversation requires an ID"
                        conversation="$2"
                        shift 2
                        ;;
                    --limit)
                        [[ -z "${2:-}" ]] && error "--limit requires a number"
                        [[ ! "$2" =~ ^[0-9]+$ ]] && error "--limit must be a positive integer"
                        limit="$2"
                        shift 2
                        ;;
                    --help|-h)
                        echo "Usage: joi-admin summaries list [--conversation ID] [--limit N]"
                        exit 0
                        ;;
                    *)
                        error "Unknown option for 'summaries list': $1"
                        ;;
                esac
            done

            local where_clause=""
            if [[ -n "$conversation" ]]; then
                local conversation_escaped
                conversation_escaped=$(sql_escape_literal "$conversation")
                where_clause="WHERE conversation_id = '$conversation_escaped'"
            fi

            local rows
            rows=$(db_exec "$(cat <<SQL
SELECT
    id,
    COALESCE(conversation_id, ''),
    COALESCE(summary_type, ''),
    COALESCE(period_start, 0),
    COALESCE(period_end, 0),
    COALESCE(message_count, 0),
    COALESCE(created_at, 0),
    substr(replace(replace(COALESCE(summary_text, ''), char(10), ' '), char(13), ' '), 1, 100)
FROM context_summaries
$where_clause
ORDER BY created_at DESC, id DESC
LIMIT $limit;
SQL
)" | awk 'NF && $0 != "ok"')

            if [[ -z "${rows//[$'\t\r\n ']/}" ]]; then
                echo "No context summaries found${conversation:+ for conversation '$conversation'}."
                exit 0
            fi

            printf "%6s  %-28s  %-12s  %8s  %13s  %13s  %-s\n" \
                "id" "conversation_id" "type" "msgs" "created_at" "period" "preview"
            printf "%6s  %-28s  %-12s  %8s  %13s  %13s  %-s\n" \
                "--" "---------------" "----" "----" "----------" "------" "-------"

            while IFS='|' read -r sid convo stype pstart pend mcount created preview; do
                [[ -z "${sid}${convo}${stype}${pstart}${pend}${mcount}${created}${preview}" ]] && continue
                [[ -z "$convo" ]] && convo="(none)"
                local period="${pstart}-${pend}"
                printf "%6s  %-28s  %-12s  %8s  %13s  %13s  %s\n" \
                    "$sid" "$convo" "$stype" "$mcount" "$created" "$period" "$preview"
            done <<< "$rows"
            ;;
        show)
            local summary_id=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --id)
                        [[ -z "${2:-}" ]] && error "--id requires a value"
                        [[ ! "$2" =~ ^[0-9]+$ ]] && error "--id must be a positive integer"
                        summary_id="$2"
                        shift 2
                        ;;
                    --help|-h)
                        echo "Usage: joi-admin summaries show --id ID"
                        exit 0
                        ;;
                    *)
                        error "Unknown option for 'summaries show': $1"
                        ;;
                esac
            done
            [[ -z "$summary_id" ]] && error "summaries show requires --id"

            local meta_row
            meta_row=$(db_exec "$(cat <<SQL
SELECT
    id,
    COALESCE(conversation_id, ''),
    COALESCE(summary_type, ''),
    COALESCE(period_start, 0),
    COALESCE(period_end, 0),
    COALESCE(message_count, 0),
    COALESCE(created_at, 0)
FROM context_summaries
WHERE id = $summary_id
LIMIT 1;
SQL
)" | awk 'NF && $0 != "ok"')

            if [[ -z "${meta_row//[$'\t\r\n ']/}" ]]; then
                echo "No context summary found with id=$summary_id."
                exit 0
            fi

            local text_hex text
            text_hex=$(db_exec "SELECT hex(COALESCE(summary_text, '')) FROM context_summaries WHERE id = $summary_id LIMIT 1;" | awk 'NF && $0 != "ok" { print; exit }')
            if [[ -n "$text_hex" ]]; then
                text=$(printf "%s" "$text_hex" | python3 -c 'import sys; h=sys.stdin.read().strip(); print(bytes.fromhex(h).decode("utf-8", errors="replace"), end="")')
            else
                text=""
            fi

            local sid convo stype pstart pend mcount created
            IFS='|' read -r sid convo stype pstart pend mcount created <<< "$meta_row"
            [[ -z "$convo" ]] && convo="(none)"

            echo "=== SUMMARY $sid ==="
            echo "conversation_id: $convo"
            echo "summary_type:    $stype"
            echo "message_count:   $mcount"
            echo "period_start:    $pstart"
            echo "period_end:      $pend"
            echo "created_at:      $created"
            echo ""
            echo "summary_text:"
            printf "%s\n" "$text"
            ;;
        delete)
            local summary_id=""
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --id)
                        [[ -z "${2:-}" ]] && error "--id requires a value"
                        [[ ! "$2" =~ ^[0-9]+$ ]] && error "--id must be a positive integer"
                        summary_id="$2"
                        shift 2
                        ;;
                    --help|-h)
                        echo "Usage: joi-admin summaries delete --id ID"
                        exit 0
                        ;;
                    *)
                        error "Unknown option for 'summaries delete': $1"
                        ;;
                esac
            done
            [[ -z "$summary_id" ]] && error "summaries delete requires --id"

            local meta_row preview
            meta_row=$(db_exec "$(cat <<SQL
SELECT
    id,
    COALESCE(conversation_id, ''),
    COALESCE(summary_type, ''),
    COALESCE(message_count, 0),
    COALESCE(created_at, 0),
    COALESCE(period_start, 0),
    COALESCE(period_end, 0)
FROM context_summaries
WHERE id = $summary_id
LIMIT 1;
SQL
)" | awk 'NF && $0 != "ok"')

            if [[ -z "${meta_row//[$'\t\r\n ']/}" ]]; then
                echo "No context summary found with id=$summary_id."
                exit 0
            fi

            preview=$(db_exec "SELECT substr(replace(replace(COALESCE(summary_text, ''), char(10), ' '), char(13), ' '), 1, 120) FROM context_summaries WHERE id = $summary_id LIMIT 1;" | awk 'NF && $0 != "ok" { print; exit }')

            local sid convo stype mcount created pstart pend
            IFS='|' read -r sid convo stype mcount created pstart pend <<< "$meta_row"
            [[ -z "$convo" ]] && convo="(none)"

            echo ""
            echo "=== SUMMARY DELETE SUMMARY ==="
            echo "  id:             $sid"
            echo "  conversation_id:$convo"
            echo "  summary_type:   $stype"
            echo "  message_count:  $mcount"
            echo "  created_at:     $created"
            echo "  period:         $pstart-$pend"
            if [[ -n "$preview" ]]; then
                echo "  preview:        $preview"
            fi
            echo ""

            read -p "Delete this summary? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo "Aborted."
                exit 1
            fi

            db_exec "DELETE FROM context_summaries WHERE id = $summary_id;"
            info "Deleted summary id=$summary_id"
            ;;
        --help|-h)
            echo "Usage: joi-admin summaries <list|show|delete> [OPTIONS]"
            exit 0
            ;;
        *)
            error "Unknown summaries subcommand: $subcommand"
            ;;
    esac
}

# Main purge command
cmd_purge() {
    local do_contexts=false
    local do_facts=false
    local do_knowledge=false
    local do_reset_counters=false
    local do_vacuum=false
    local do_hmac=false
    local do_nebula_keys=false
    local do_nebula_ca=false
    local conversation=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --contexts)
                do_contexts=true
                shift
                ;;
            --facts)
                do_facts=true
                shift
                ;;
            --knowledge)
                do_knowledge=true
                shift
                ;;
            --all-data)
                do_contexts=true
                do_facts=true
                do_knowledge=true
                shift
                ;;
            --reset-counters)
                do_reset_counters=true
                shift
                ;;
            --vacuum)
                do_vacuum=true
                shift
                ;;
            --conversation)
                [[ -z "${2:-}" ]] && error "--conversation requires an ID"
                conversation="$2"
                shift 2
                ;;
            --hmac-key)
                do_hmac=true
                shift
                ;;
            --nebula-keys)
                do_nebula_keys=true
                shift
                ;;
            --all-keys)
                do_hmac=true
                do_nebula_keys=true
                shift
                ;;
            --everything)
                do_contexts=true
                do_facts=true
                do_knowledge=true
                do_hmac=true
                do_nebula_keys=true
                shift
                ;;
            --nebula-ca)
                do_nebula_ca=true
                shift
                ;;
            --help|-h)
                usage
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    # Check if anything to do
    if ! $do_contexts && ! $do_facts && ! $do_knowledge && ! $do_hmac && ! $do_nebula_keys && ! $do_nebula_ca && ! $do_reset_counters && ! $do_vacuum; then
        echo "No purge flags specified. Nothing to do."
        echo ""
        echo "Run 'joi-admin purge --help' for usage."
        exit 0
    fi

    # Safety check for nuclear options
    if $do_nebula_ca && ! $do_nebula_keys; then
        error "--nebula-ca requires --nebula-keys or --everything"
    fi

    # Counter reset safety checks
    if $do_reset_counters; then
        if [[ -n "$conversation" ]]; then
            error "--reset-counters cannot be used with --conversation"
        fi
        if ! $do_contexts || ! $do_facts || ! $do_knowledge; then
            error "--reset-counters requires full memory purge: --all-data (or --contexts --facts --knowledge)"
        fi
    fi

    # Vacuum safety checks
    if $do_vacuum; then
        if [[ -n "$conversation" ]]; then
            error "--vacuum cannot be used with --conversation"
        fi
        if ! $do_contexts || ! $do_facts || ! $do_knowledge; then
            error "--vacuum requires full memory purge: --all-data (or --contexts --facts --knowledge)"
        fi
    fi

    # Confirm destructive action
    echo ""
    echo "=== PURGE SUMMARY ==="
    $do_contexts && echo "  - Contexts (messages, summaries)"
    $do_facts && echo "  - User facts"
    $do_knowledge && echo "  - Knowledge chunks"
    $do_reset_counters && echo "  - Reset AUTOINCREMENT counters"
    $do_vacuum && echo "  - VACUUM memory database"
    $do_hmac && echo "  - HMAC key (regenerate)"
    $do_nebula_keys && echo "  - Nebula host keys"
    $do_nebula_ca && echo "  - Nebula CA certificate"
    [[ -n "$conversation" ]] && echo "  Scope: conversation $conversation" || echo "  Scope: ALL"
    echo ""

    read -p "Are you sure? This cannot be undone. [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 1
    fi

    if $do_vacuum; then
        echo ""
        warn "VACUUM rewrites the entire database file."
        warn "Ensure sufficient free disk space (roughly at least DB size)."
        warn "If joi-api is running and writing to DB, VACUUM can fail (database locked)."
        warn "Recommended: stop joi-api before running purge with --vacuum."

        read -p "Proceed with VACUUM after purge? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Aborted."
            exit 1
        fi

        read -p "Confirm VACUUM again (second confirmation) [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Aborted."
            exit 1
        fi
    fi

    echo ""
    echo "=== PURGING ==="

    # Execute purges
    $do_contexts && purge_contexts "$conversation"
    $do_facts && purge_facts "$conversation"
    $do_knowledge && purge_knowledge
    $do_reset_counters && reset_autoincrement_counters
    $do_vacuum && vacuum_memory_db

    # Reset system state if purging all data
    if $do_contexts && $do_facts && [[ -z "$conversation" ]]; then
        reset_system_state
    fi

    $do_hmac && regenerate_hmac
    $do_nebula_keys && purge_nebula_keys
    $do_nebula_ca && purge_nebula_ca

    echo ""
    info "=== PURGE COMPLETE ==="

    # Reminders
    if $do_hmac; then
        echo ""
        warn "REMINDER: Update HMAC key on Mesh VM to match!"
    fi

    if $do_nebula_keys || $do_nebula_ca; then
        echo ""
        warn "REMINDER: Nebula re-enrollment required before network connectivity!"
    fi
}

# Main entry point
main() {
    if [[ $# -lt 1 ]]; then
        usage
    fi

    local command="$1"
    shift

    case "$command" in
        purge)
            check_root
            cmd_purge "$@"
            ;;
        rag)
            check_root
            cmd_rag "$@"
            ;;
        summaries)
            check_root
            cmd_summaries "$@"
            ;;
        --help|-h)
            usage
            ;;
        *)
            error "Unknown command: $command. Run '$SCRIPT_NAME --help' for usage."
            ;;
    esac
}

main "$@"
