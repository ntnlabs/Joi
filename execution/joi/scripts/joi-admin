#!/bin/bash
# Joi Admin Tool - Memory and key management
#
# Usage: sudo joi-admin purge [FLAGS]
#
# SAFE BY DEFAULT: No flags = no action. Must explicitly specify what to purge.

set -Eeuo pipefail

SCRIPT_NAME=$(basename "$0")
MEMORY_DB="${JOI_MEMORY_DB:-/var/lib/joi/memory.db}"
NONCE_DB="${JOI_NONCE_DB:-/var/lib/joi/nonces.db}"
HMAC_KEY_FILE="${JOI_HMAC_KEY_FILE:-/etc/joi/hmac.key}"
MEMORY_KEY_FILE="${JOI_MEMORY_KEY_FILE:-/etc/joi/memory.key}"
SQLCIPHER_BIN="${JOI_SQLCIPHER_BIN:-sqlcipher}"
NEBULA_DIR="/etc/nebula"
SERVICE_USER="${JOI_SERVICE_USER:-joi}"
DB_MODE=""
DB_KEY=""
DB_MODE_INITIALIZED=false

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m' # No Color
DEBUG="${JOI_ADMIN_DEBUG:-0}"

if [[ "$DEBUG" == "1" ]]; then
    set -x
fi

on_err() {
    local exit_code=$?
    echo -e "${RED}Error at line ${BASH_LINENO[0]}: ${BASH_COMMAND} (exit ${exit_code})${NC}" >&2
    exit "$exit_code"
}

trap on_err ERR

usage() {
    cat << 'EOF'
Joi Admin Tool

USAGE:
    joi-admin <COMMAND> [OPTIONS]

COMMANDS:
    purge       Purge memory data and/or regenerate keys

PURGE USAGE:
    joi-admin purge [FLAGS]

    SAFE BY DEFAULT: Running without flags does nothing.

DATA FLAGS (what to delete):
    --contexts          Delete messages and context summaries
    --facts             Delete learned user facts
    --knowledge         Delete RAG knowledge chunks
    --all-data          All of the above (contexts + facts + knowledge)

RESET FLAGS:
    --reset-counters    Reset AUTOINCREMENT counters (sqlite_sequence) for
                        messages, user_facts, context_summaries, knowledge_chunks
                        Requires global full-memory purge (no --conversation)
    --vacuum            Compact memory DB file after purge (VACUUM)
                        Requires global full-memory purge (no --conversation)
                        Shows extra warnings and asks for double confirmation

SCOPE FLAGS (limit deletion):
    --conversation ID   Only affect specific conversation (phone/group ID)
                        Without this, affects ALL conversations

KEY FLAGS:
    --hmac-key          Regenerate HMAC signing key
    --nebula-keys       Remove Nebula host keys (requires re-enrollment)
    --all-keys          Both HMAC and Nebula keys

NUCLEAR OPTIONS:
    --everything        Equivalent to --all-data --all-keys
    --nebula-ca         Also remove Nebula CA cert (true factory reset)

EXAMPLES:
    joi-admin purge                                    # Does nothing (safe)
    joi-admin purge --contexts                         # Clear all conversation history
    joi-admin purge --contexts --conversation +1234    # Clear one conversation (//reload)
    joi-admin purge --contexts --facts --conversation +1234  # //restart equivalent
    joi-admin purge --all-data --conversation +1234    # //reset equivalent
    joi-admin purge --all-data --reset-counters        # Full data purge + ID counters reset
    joi-admin purge --all-data --reset-counters --vacuum
    joi-admin purge --all-data --all-keys              # Customer handoff
    joi-admin purge --everything --nebula-ca           # True factory reset

EOF
    exit 0
}

error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

warn() {
    echo -e "${YELLOW}Warning: $1${NC}" >&2
}

info() {
    echo -e "${GREEN}$1${NC}"
}

# Check if running as root
check_root() {
    if [[ $EUID -ne 0 ]]; then
        error "This script must be run as root (sudo)"
    fi
}

sql_escape_literal() {
    # Escape single quotes for SQL string literals.
    printf "%s" "$1" | sed "s/'/''/g"
}

ensure_db_mode() {
    if $DB_MODE_INITIALIZED; then
        return
    fi
    DB_MODE_INITIALIZED=true

    if [[ ! -f "$MEMORY_DB" ]]; then
        return
    fi

    if command -v sqlite3 >/dev/null 2>&1; then
        # Probe schema access (not just SELECT 1), so encrypted DBs are rejected.
        if sqlite3 "$MEMORY_DB" "SELECT count(*) FROM sqlite_master WHERE type='table';" >/dev/null 2>&1; then
            DB_MODE="sqlite3"
            return
        fi
    fi

    if command -v "$SQLCIPHER_BIN" >/dev/null 2>&1; then
        if [[ -f "$MEMORY_KEY_FILE" ]]; then
            DB_KEY=$(tr -d '\r\n' < "$MEMORY_KEY_FILE")
            if [[ -n "$DB_KEY" ]]; then
                if "$SQLCIPHER_BIN" "$MEMORY_DB" <<EOF >/dev/null 2>&1
PRAGMA key = '$DB_KEY';
SELECT count(*) FROM sqlite_master WHERE type='table';
EOF
                then
                    DB_MODE="sqlcipher_key"
                    return
                fi
            fi
        fi

        # Fallback: sqlcipher can also open plaintext DBs.
        if "$SQLCIPHER_BIN" "$MEMORY_DB" "SELECT count(*) FROM sqlite_master WHERE type='table';" >/dev/null 2>&1; then
            DB_MODE="sqlcipher_plain"
            return
        fi
    fi

    error "Cannot open memory DB ($MEMORY_DB). Install sqlite3/sqlcipher and check JOI_MEMORY_KEY_FILE."
}

db_exec() {
    local sql="$1"
    ensure_db_mode

    if [[ "$DEBUG" == "1" ]]; then
        echo "[DEBUG] DB mode: ${DB_MODE}" >&2
        echo "[DEBUG] SQL: ${sql}" >&2
    fi

    case "$DB_MODE" in
        sqlite3)
            sqlite3 "$MEMORY_DB" "$sql"
            ;;
        sqlcipher_key)
            "$SQLCIPHER_BIN" "$MEMORY_DB" <<EOF
PRAGMA key = '$DB_KEY';
$sql
EOF
            ;;
        sqlcipher_plain)
            "$SQLCIPHER_BIN" "$MEMORY_DB" "$sql"
            ;;
        *)
            error "Database engine not initialized"
            ;;
    esac
}

db_scalar() {
    local sql="$1"
    local output
    output=$(db_exec "$sql")

    # sqlcipher can emit a standalone "ok" line from PRAGMA key.
    # Return first real scalar value.
    printf "%s\n" "$output" | awk 'NF && $0 != "ok" { print; exit }'
}

# Purge messages and summaries
purge_contexts() {
    local conversation="$1"
    local count=0

    if [[ ! -f "$MEMORY_DB" ]]; then
        warn "Memory database not found: $MEMORY_DB"
        return
    fi

    if [[ -n "$conversation" ]]; then
        local conversation_escaped
        conversation_escaped=$(sql_escape_literal "$conversation")
        echo "Purging contexts for conversation: $conversation"
        count=$(db_scalar "SELECT COUNT(*) FROM messages WHERE conversation_id = '$conversation_escaped';")
        # Break self-referential reply chains before deleting parent rows.
        # Without this, SQLite can fail with FOREIGN KEY constraint errors.
        db_exec "UPDATE messages SET reply_to_id = NULL WHERE reply_to_id IN (SELECT message_id FROM messages WHERE conversation_id = '$conversation_escaped');"
        db_exec "DELETE FROM messages WHERE conversation_id = '$conversation_escaped';"
        db_exec "DELETE FROM context_summaries WHERE conversation_id = '$conversation_escaped';"
    else
        echo "Purging ALL contexts"
        count=$(db_scalar "SELECT COUNT(*) FROM messages;")
        # Clear reply links first to avoid FK failures on bulk delete.
        db_exec "UPDATE messages SET reply_to_id = NULL WHERE reply_to_id IS NOT NULL;"
        db_exec "DELETE FROM messages;"
        db_exec "DELETE FROM context_summaries;"
    fi

    info "  Deleted $count messages"
}

# Purge user facts
purge_facts() {
    local conversation="$1"
    local count=0

    if [[ ! -f "$MEMORY_DB" ]]; then
        warn "Memory database not found: $MEMORY_DB"
        return
    fi

    if [[ -n "$conversation" ]]; then
        local conversation_escaped
        conversation_escaped=$(sql_escape_literal "$conversation")
        echo "Purging facts for conversation: $conversation"
        count=$(db_scalar "SELECT COUNT(*) FROM user_facts WHERE conversation_id = '$conversation_escaped';")
        db_exec "DELETE FROM user_facts WHERE conversation_id = '$conversation_escaped';"
    else
        echo "Purging ALL facts"
        count=$(db_scalar "SELECT COUNT(*) FROM user_facts;")
        db_exec "DELETE FROM user_facts;"
    fi

    info "  Deleted $count facts"
}

# Purge knowledge chunks
purge_knowledge() {
    local count=0
    local delete_err=""

    if [[ ! -f "$MEMORY_DB" ]]; then
        warn "Memory database not found: $MEMORY_DB"
        return
    fi

    echo "Purging knowledge chunks"
    count=$(db_scalar "SELECT COUNT(*) FROM knowledge_chunks;")

    # Primary path: delete chunks directly.
    # Fallback path: some sqlcipher builds lack FTS5 module and fail via triggers.
    if ! delete_err=$(db_exec "DELETE FROM knowledge_chunks;" 2>&1); then
        if printf "%s" "$delete_err" | grep -qi "no such module: fts5"; then
            warn "FTS5 module unavailable in current sqlcipher; dropping knowledge FTS triggers and retrying."
            db_exec "DROP TRIGGER IF EXISTS knowledge_ai;"
            db_exec "DROP TRIGGER IF EXISTS knowledge_ad;"
            db_exec "DROP TRIGGER IF EXISTS knowledge_au;"
            db_exec "DELETE FROM knowledge_chunks;"
        else
            printf "%s\n" "$delete_err" >&2
            error "Failed to purge knowledge chunks"
        fi
    fi

    # Also clear FTS index if available in this engine build.
    if ! db_exec "DELETE FROM knowledge_fts;" >/dev/null 2>&1; then
        warn "Skipping knowledge_fts clear (FTS5 module not available in this sqlcipher build)."
    fi

    info "  Deleted $count knowledge chunks"
}

# Purge nonce database
purge_nonces() {
    if [[ -f "$NONCE_DB" ]]; then
        echo "Purging nonce database"
        rm -f "$NONCE_DB"
        info "  Deleted $NONCE_DB"
    fi
}

# Regenerate HMAC key
regenerate_hmac() {
    echo "Regenerating HMAC key"

    local key_dir
    key_dir=$(dirname "$HMAC_KEY_FILE")

    if [[ ! -d "$key_dir" ]]; then
        mkdir -p "$key_dir"
        chown "$SERVICE_USER:$SERVICE_USER" "$key_dir"
        chmod 700 "$key_dir"
    fi

    # Generate new key
    local new_key
    new_key=$(openssl rand -hex 32)

    umask 077
    echo "$new_key" > "$HMAC_KEY_FILE"
    chmod 600 "$HMAC_KEY_FILE"
    chown "$SERVICE_USER:$SERVICE_USER" "$HMAC_KEY_FILE"

    # Also purge nonces since old signatures are invalid
    purge_nonces

    info "  New HMAC key written to $HMAC_KEY_FILE"
    warn "  Mesh VM must also update its HMAC key to match!"
}

# Remove Nebula host keys
purge_nebula_keys() {
    echo "Removing Nebula host keys"

    local removed=0
    for f in "$NEBULA_DIR"/host.key "$NEBULA_DIR"/host.crt; do
        if [[ -f "$f" ]]; then
            rm -f "$f"
            info "  Deleted $f"
            ((removed++))
        fi
    done

    if [[ $removed -eq 0 ]]; then
        warn "  No Nebula host keys found"
    else
        warn "  Host must be re-enrolled with Nebula CA"
    fi
}

# Remove Nebula CA (factory reset)
purge_nebula_ca() {
    echo "Removing Nebula CA certificate"

    if [[ -f "$NEBULA_DIR/ca.crt" ]]; then
        rm -f "$NEBULA_DIR/ca.crt"
        info "  Deleted $NEBULA_DIR/ca.crt"
        warn "  Complete Nebula re-setup required!"
    else
        warn "  No Nebula CA found"
    fi
}

# Reset system state
reset_system_state() {
    if [[ ! -f "$MEMORY_DB" ]]; then
        return
    fi

    echo "Resetting system state"
    db_exec "$(cat << 'SQL'
UPDATE system_state SET value = '0' WHERE key IN (
    'last_interaction_at',
    'last_impulse_check_at',
    'messages_sent_this_hour',
    'messages_sent_hour_start',
    'last_context_cleanup_at',
    'last_memory_consolidation_at'
);
UPDATE system_state SET value = '' WHERE key = 'current_conversation_topic';
UPDATE system_state SET value = '"idle"' WHERE key = 'agent_state';
SQL
)"
    info "  System state reset"
}

reset_autoincrement_counters() {
    if [[ ! -f "$MEMORY_DB" ]]; then
        return
    fi

    echo "Resetting AUTOINCREMENT counters"

    local non_empty_tables
    non_empty_tables=$(db_exec "$(cat << 'SQL'
SELECT table_name || ' (' || row_count || ' rows)'
FROM (
    SELECT 'messages' AS table_name, COUNT(*) AS row_count FROM messages
    UNION ALL
    SELECT 'user_facts', COUNT(*) FROM user_facts
    UNION ALL
    SELECT 'context_summaries', COUNT(*) FROM context_summaries
    UNION ALL
    SELECT 'knowledge_chunks', COUNT(*) FROM knowledge_chunks
) t
WHERE row_count > 0
ORDER BY table_name;
SQL
)" | awk 'NF && $0 != "ok"')

    if [[ -n "${non_empty_tables//[$'\t\r\n ']/}" ]]; then
        error "--reset-counters requires empty memory tables, found data in: $non_empty_tables"
    fi

    db_exec "DELETE FROM sqlite_sequence WHERE name IN ('messages','user_facts','context_summaries','knowledge_chunks');"
    info "  AUTOINCREMENT counters reset"
}

vacuum_memory_db() {
    if [[ ! -f "$MEMORY_DB" ]]; then
        warn "Memory database not found: $MEMORY_DB"
        return
    fi

    echo "Running VACUUM on memory database"
    db_exec "VACUUM;"
    info "  Memory database compacted"
}

# Main purge command
cmd_purge() {
    local do_contexts=false
    local do_facts=false
    local do_knowledge=false
    local do_reset_counters=false
    local do_vacuum=false
    local do_hmac=false
    local do_nebula_keys=false
    local do_nebula_ca=false
    local conversation=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --contexts)
                do_contexts=true
                shift
                ;;
            --facts)
                do_facts=true
                shift
                ;;
            --knowledge)
                do_knowledge=true
                shift
                ;;
            --all-data)
                do_contexts=true
                do_facts=true
                do_knowledge=true
                shift
                ;;
            --reset-counters)
                do_reset_counters=true
                shift
                ;;
            --vacuum)
                do_vacuum=true
                shift
                ;;
            --conversation)
                [[ -z "${2:-}" ]] && error "--conversation requires an ID"
                conversation="$2"
                shift 2
                ;;
            --hmac-key)
                do_hmac=true
                shift
                ;;
            --nebula-keys)
                do_nebula_keys=true
                shift
                ;;
            --all-keys)
                do_hmac=true
                do_nebula_keys=true
                shift
                ;;
            --everything)
                do_contexts=true
                do_facts=true
                do_knowledge=true
                do_hmac=true
                do_nebula_keys=true
                shift
                ;;
            --nebula-ca)
                do_nebula_ca=true
                shift
                ;;
            --help|-h)
                usage
                ;;
            *)
                error "Unknown option: $1"
                ;;
        esac
    done

    # Check if anything to do
    if ! $do_contexts && ! $do_facts && ! $do_knowledge && ! $do_hmac && ! $do_nebula_keys && ! $do_nebula_ca && ! $do_reset_counters && ! $do_vacuum; then
        echo "No purge flags specified. Nothing to do."
        echo ""
        echo "Run 'joi-admin purge --help' for usage."
        exit 0
    fi

    # Safety check for nuclear options
    if $do_nebula_ca && ! $do_nebula_keys; then
        error "--nebula-ca requires --nebula-keys or --everything"
    fi

    # Counter reset safety checks
    if $do_reset_counters; then
        if [[ -n "$conversation" ]]; then
            error "--reset-counters cannot be used with --conversation"
        fi
        if ! $do_contexts || ! $do_facts || ! $do_knowledge; then
            error "--reset-counters requires full memory purge: --all-data (or --contexts --facts --knowledge)"
        fi
    fi

    # Vacuum safety checks
    if $do_vacuum; then
        if [[ -n "$conversation" ]]; then
            error "--vacuum cannot be used with --conversation"
        fi
        if ! $do_contexts || ! $do_facts || ! $do_knowledge; then
            error "--vacuum requires full memory purge: --all-data (or --contexts --facts --knowledge)"
        fi
    fi

    # Confirm destructive action
    echo ""
    echo "=== PURGE SUMMARY ==="
    $do_contexts && echo "  - Contexts (messages, summaries)"
    $do_facts && echo "  - User facts"
    $do_knowledge && echo "  - Knowledge chunks"
    $do_reset_counters && echo "  - Reset AUTOINCREMENT counters"
    $do_vacuum && echo "  - VACUUM memory database"
    $do_hmac && echo "  - HMAC key (regenerate)"
    $do_nebula_keys && echo "  - Nebula host keys"
    $do_nebula_ca && echo "  - Nebula CA certificate"
    [[ -n "$conversation" ]] && echo "  Scope: conversation $conversation" || echo "  Scope: ALL"
    echo ""

    read -p "Are you sure? This cannot be undone. [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 1
    fi

    if $do_vacuum; then
        echo ""
        warn "VACUUM rewrites the entire database file."
        warn "Ensure sufficient free disk space (roughly at least DB size)."
        warn "If joi-api is running and writing to DB, VACUUM can fail (database locked)."
        warn "Recommended: stop joi-api before running purge with --vacuum."

        read -p "Proceed with VACUUM after purge? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Aborted."
            exit 1
        fi

        read -p "Confirm VACUUM again (second confirmation) [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Aborted."
            exit 1
        fi
    fi

    echo ""
    echo "=== PURGING ==="

    # Execute purges
    $do_contexts && purge_contexts "$conversation"
    $do_facts && purge_facts "$conversation"
    $do_knowledge && purge_knowledge
    $do_reset_counters && reset_autoincrement_counters
    $do_vacuum && vacuum_memory_db

    # Reset system state if purging all data
    if $do_contexts && $do_facts && [[ -z "$conversation" ]]; then
        reset_system_state
    fi

    $do_hmac && regenerate_hmac
    $do_nebula_keys && purge_nebula_keys
    $do_nebula_ca && purge_nebula_ca

    echo ""
    info "=== PURGE COMPLETE ==="

    # Reminders
    if $do_hmac; then
        echo ""
        warn "REMINDER: Update HMAC key on Mesh VM to match!"
    fi

    if $do_nebula_keys || $do_nebula_ca; then
        echo ""
        warn "REMINDER: Nebula re-enrollment required before network connectivity!"
    fi
}

# Main entry point
main() {
    if [[ $# -lt 1 ]]; then
        usage
    fi

    local command="$1"
    shift

    case "$command" in
        purge)
            check_root
            cmd_purge "$@"
            ;;
        --help|-h)
            usage
            ;;
        *)
            error "Unknown command: $command. Run '$SCRIPT_NAME --help' for usage."
            ;;
    esac
}

main "$@"
